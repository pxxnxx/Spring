<영속성 컨텍스트 1>
    영속성 컨텍스트 == 엔티티를 영구 저장하는 환경
    엔티티 매니저를 통해 영속성 컨텍스트에 접근

    비영속 - 영속성 컨텍스트와 상관없는 새로운 상태
    영속 - 영속성 컨텍스트에 관리되는 상태 (Transaction commit -> Query)
    준영속 - 영속성 컨텍스트에 저장되었다가 분리된 상태
    삭제 - 삭제된 상태

<영속성 컨텍스트 2>
    1차 캐시 - 영속시 PK <-> Entity 매핑하여 1차 캐시에 저장 (한 Transaction이라 큰 영향 X)
    동일성 보장 - 1차 캐시를 통해 같은 Transaction에서 Entity끼리 동일성 보장
    쓰기 지연 - 1차 캐시를 통해 바로 SQL 처리하지 않고 Commit시 처리 가능
    변경 감지 - Flush -> 스냅샷 비교 -> Update SQL -> Flush -> Commit
    지연 로딩

    JPA에는 동적 객체 생성때문에 기본 생성자 필요

<플러시>
    영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화
    변경 감지 -> SQL 저장소에 등록 -> Commit시 처리
    기본적으로 자동 호출이며(JPQL 실행시에도 호출) em.flush() 통해 직접 호출 가능
    1차 캐시 유지됨

<준영속 상태>
    영속성 컨텍스트에서 분리, 업데이트 되지 않음

<객체와 테이블 매핑>
    객체와 테이블 매핑 : @Entity, @Table
    @Entity는 JPA가 관리. 기본 생성자 필수, final 사용 X
    기본값은 클래스 이름. 변경 필요 시 name 이용

<데이터베이스 스키마 자동 생성>
    DDL을 애플리케이션 실행 시점에서 자동 생성. DB Table을 생성해줌
    데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성
    방언 별로 변경 됨
    개발에서만 사용 해야함 // 그래도 가급적으로 사용 X
    초기에는 create, update
    테스트 서버 update, validate
    스테이징과 운영 서버 validate, none

    create - 기존 테이블 존재시 삭제후 생성
    create-drop - 종료시점에 삭제
    update - 변경분만 적용 // 지우는 것은 안됨
    validate - 엔티티와 테이블 정상 매핑되었는지만 확인
    none - 없음

    @Column(unique = true, length = 10) 이런식으로 조건 줄 수 있음
    JPA 실행 로직에 영향 주지 않아 사용해도 괜찮음

<필드와 컬럼 매핑>
    @Column - 컬럼 매핑
        nullable = false <- null값 허용 X
        unique는 주로 @Table에서 이용
    @Temporal - 날짜 타입 매핑
        TemporalType 3개 있음 매핑 필요
        LocalDate, LocalDateTime 이용 시 @Temporal 매핑 필요 X
    @Enumerated - Enum 타입 매핑
        Ordinal - Enum 순서를 데이터베이스에 저장
        String - Enum 이름을 데이터베이스에 저장
        기본 - Ordinal, 순서가 바뀔 수 있으니 String 사용 필수
    @Lob - BLOB, CLOB 매핑
        Varchar 넘어서는 컨텐츠 넣고 싶으면 이용 // 문자열일경우 Clob
    @Transient - 특정 필드를 컬럼에 매핑하지 않음

<기본 키 매핑>
    직접 할당 : @Id만 사용
    자동 생성 : @GeneratedValue
        Identity, Sequence, Table, Auto
        Identity <- DB에 들어가야 Id값 알 수 있음. 그래서 Persist할 때 Query (큰 문제는 X)
        Sequence <- Sequence만 받아와서 바로 Query X
        Table <-

        allocationSize 이용하면 DB에 미리 올려놓아서 네트워크 연결 여러번 안해도 됨
            - Sequence, Table에서 이용. 동시성 문제 X
    기본 키 제약 조건 : null 아님, 유일, 변하면 안됨.
        만족하는 자연키 찾기 어려움 -> 대체키 사용
    권장 : Long형 + 대체키 + 키 생성전략 사용

<요구사항 분석과 기본 매핑>
    회원 - 주문 : 일대다
    주문 - 상품 : 다대다
    -> 주문 상품 만들어 일대다 다대일로 만듦
    데이터 중심 설계의 문제점
        - 테이블의 외래키를 객체에 그대로 가져옴
        - 객체 그래프 탐색이 불가능
        - 참조가 없으므로 UML도 잘못됨

<단방향 연관관계>
    select * from member m join team t on m.team_id = t.team_id;
    객체를 테이블에 맞추어 데이터 중심으로 모델링하면 협력 관계를 만들 수 없음.
    단방향 연관관계
    member 입장에서 Many라서 @ManyToOne, @JoinColumn 이용하면 매핑 가능

*중요함*
<양방향 연관관계와 연관관계의 주인 1 - 기본>
    양방향 객체 연관관계로 바꾸어도 테이블 연관관계는 차이 X
    team 입장에서는 One이라서 @OneToMany, mappedBy로 매핑된 요소 지정
    flush, clear해야 값이 나옴 <- 이유 : 1차 캐시에는 컬렉션 값이 없음
    객체는 단방향 매핑이 신경쓸 것이 많이 없음

    *mappedBy 중요*
    객체 테이블 양방향 관계 차이점
        객체 연관관계 == 2개
            회원 -> 팀 (단방향)
            팀 -> 회원 (단방향)
        테이블 연관관계 == 1개
            회원 <-> 팀 (양방향) // Key 하나로 둘다 확인 가능. 방향 없다고 봐도 됨
    => 둘중 하나로 외래 키 관리해야 함.

    => *Owner*
    주인만이 외래 키를 관리
    주인은 mappedBy 속성 사용 X
    외래 키가 있는 곳을 주인으로 정해야 함. (N:1 의 N)

<양방향 연관관계와 연관관계의 주인 2 - 주의점, 정리>
    member가 owner이기 때문에
    team.getMembers().add(member) X
    member.setTeam(team) O
    순수 객체 상태 고려해서 둘다 입력하는 것을 권장
        -> flush, clear 없어도 값이 나옴 (1차 캐시에 컬렉션 저장)
    연관관계 편의 메소드 생성 권장
        -> setTeam에 team.getMembers().add(this) 추가
    setTeam 대신 addMember 이용해도 되지만 둘 중 하나만 이용할 것
    양방향 매핑시 무한 루프 ex) toString, lombok, JSON 생성 라이브러리
    Entity는 Controller로 반환 X

    정리
        단방향 매핑만으로도 이미 연관관계 매핑은 완료
        양방향 매핑은 반대 방향으로 조회 기능이 추가된 것 뿐
        JPQL에서 역방향으로 탐색할 일이 많음
        단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 됨

<연관관계 매핑 시작>
    Member에 Orders List를 넣어두는 것은 좋지 않은 설계

<정리>
    연관관계 매핑시 고려사항
        - 다중성
        - 단방향, 양방향
        - 연관관계의 주인

    다중성
        - 다대일 @ManyToOne *
        - 일대다 @OneToMany *
        - 일대일 @OneToOne
        - 다대다 @ManyToMany <- 쓰면 안됨

    단방향, 양방향
        - 테이블
            외래 키 하나로 양쪽 조인 가능
            사실 방향이라는 개념이 없음
        - 객체
            참조용 필드가 있는 쪽을뫈 참조 가능
            한쪽만 참조하면 단방향
            양쪽이 서로 참조하면 양방향 (단방향 두개)
    연관관계의 주인
        테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음
        객체 양방향 관계는 A->B, B->A 처럼 참조가 2군데
            -> 외래키 관리할 곳 지정해야 함
        연관관계의 주인 : 외래 키를 관리하는 참조
        주인의 반대편 : 외래 키에 영향을 주지 않음, 단순 조회만

<다대일 [N:1]>
    가장 많이 사용하는 연관관계
    다대일의 반대는 일대다



