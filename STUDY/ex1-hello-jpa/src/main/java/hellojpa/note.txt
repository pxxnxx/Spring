<영속성 컨텍스트 1>
    영속성 컨텍스트 == 엔티티를 영구 저장하는 환경
    엔티티 매니저를 통해 영속성 컨텍스트에 접근

    비영속 - 영속성 컨텍스트와 상관없는 새로운 상태
    영속 - 영속성 컨텍스트에 관리되는 상태 (Transaction commit -> Query)
    준영속 - 영속성 컨텍스트에 저장되었다가 분리된 상태
    삭제 - 삭제된 상태

<영속성 컨텍스트 2>
    1차 캐시 - 영속시 PK <-> Entity 매핑하여 1차 캐시에 저장 (한 Transaction이라 큰 영향 X)
    동일성 보장 - 1차 캐시를 통해 같은 Transaction에서 Entity끼리 동일성 보장
    쓰기 지연 - 1차 캐시를 통해 바로 SQL 처리하지 않고 Commit시 처리 가능
    변경 감지 - Flush -> 스냅샷 비교 -> Update SQL -> Flush -> Commit
    지연 로딩

    JPA에는 동적 객체 생성때문에 기본 생성자 필요

<플러시>
    영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화
    변경 감지 -> SQL 저장소에 등록 -> Commit시 처리
    기본적으로 자동 호출이며(JPQL 실행시에도 호출) em.flush() 통해 직접 호출 가능
    1차 캐시 유지됨

<준영속 상태>
    영속성 컨텍스트에서 분리, 업데이트 되지 않음

<객체와 테이블 매핑>
    객체와 테이블 매핑 : @Entity, @Table
    @Entity는 JPA가 관리. 기본 생성자 필수, final 사용 X
    기본값은 클래스 이름. 변경 필요 시 name 이용

<데이터베이스 스키마 자동 생성>
    DDL을 애플리케이션 실행 시점에서 자동 생성. DB Table을 생성해줌
    데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성
    방언 별로 변경 됨
    개발에서만 사용 해야함 // 그래도 가급적으로 사용 X
    초기에는 create, update
    테스트 서버 update, validate
    스테이징과 운영 서버 validate, none

    create - 기존 테이블 존재시 삭제후 생성
    create-drop - 종료시점에 삭제
    update - 변경분만 적용 // 지우는 것은 안됨
    validate - 엔티티와 테이블 정상 매핑되었는지만 확인
    none - 없음

    @Column(unique = true, length = 10) 이런식으로 조건 줄 수 있음
    JPA 실행 로직에 영향 주지 않아 사용해도 괜찮음

