<영속성 컨텍스트 1>
    영속성 컨텍스트 == 엔티티를 영구 저장하는 환경
    엔티티 매니저를 통해 영속성 컨텍스트에 접근

    비영속 - 영속성 컨텍스트와 상관없는 새로운 상태
    영속 - 영속성 컨텍스트에 관리되는 상태 (Transaction commit -> Query)
    준영속 - 영속성 컨텍스트에 저장되었다가 분리된 상태
    삭제 - 삭제된 상태

<영속성 컨텍스트 2>
    1차 캐시 - 영속시 PK <-> Entity 매핑하여 1차 캐시에 저장 (한 Transaction이라 큰 영향 X)
    동일성 보장 - 1차 캐시를 통해 같은 Transaction에서 Entity끼리 동일성 보장
    쓰기 지연 - 1차 캐시를 통해 바로 SQL 처리하지 않고 Commit시 처리 가능
    변경 감지 - Flush -> 스냅샷 비교 -> Update SQL -> Flush -> Commit
    지연 로딩

    JPA에는 동적 객체 생성때문에 기본 생성자 필요

<플러시>
    영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화
    변경 감지 -> SQL 저장소에 등록 -> Commit시 처리
    기본적으로 자동 호출이며(JPQL 실행시에도 호출) em.flush() 통해 직접 호출 가능
    1차 캐시 유지됨

<준영속 상태>
    영속성 컨텍스트에서 분리, 업데이트 되지 않음

<객체와 테이블 매핑>
    객체와 테이블 매핑 : @Entity, @Table
    @Entity는 JPA가 관리. 기본 생성자 필수, final 사용 X
    기본값은 클래스 이름. 변경 필요 시 name 이용

<데이터베이스 스키마 자동 생성>
    DDL을 애플리케이션 실행 시점에서 자동 생성. DB Table을 생성해줌
    데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성
    방언 별로 변경 됨
    개발에서만 사용 해야함 // 그래도 가급적으로 사용 X
    초기에는 create, update
    테스트 서버 update, validate
    스테이징과 운영 서버 validate, none

    create - 기존 테이블 존재시 삭제후 생성
    create-drop - 종료시점에 삭제
    update - 변경분만 적용 // 지우는 것은 안됨
    validate - 엔티티와 테이블 정상 매핑되었는지만 확인
    none - 없음

    @Column(unique = true, length = 10) 이런식으로 조건 줄 수 있음
    JPA 실행 로직에 영향 주지 않아 사용해도 괜찮음

<필드와 컬럼 매핑>
    @Column - 컬럼 매핑
        nullable = false <- null값 허용 X
        unique는 주로 @Table에서 이용
    @Temporal - 날짜 타입 매핑
        TemporalType 3개 있음 매핑 필요
        LocalDate, LocalDateTime 이용 시 @Temporal 매핑 필요 X
    @Enumerated - Enum 타입 매핑
        Ordinal - Enum 순서를 데이터베이스에 저장
        String - Enum 이름을 데이터베이스에 저장
        기본 - Ordinal, 순서가 바뀔 수 있으니 String 사용 필수
    @Lob - BLOB, CLOB 매핑
        Varchar 넘어서는 컨텐츠 넣고 싶으면 이용 // 문자열일경우 Clob
    @Transient - 특정 필드를 컬럼에 매핑하지 않음

<기본 키 매핑>
    직접 할당 : @Id만 사용
    자동 생성 : @GeneratedValue
        Identity, Sequence, Table, Auto
        Identity <- DB에 들어가야 Id값 알 수 있음. 그래서 Persist할 때 Query (큰 문제는 X)
        Sequence <- Sequence만 받아와서 바로 Query X
        Table <-

        allocationSize 이용하면 DB에 미리 올려놓아서 네트워크 연결 여러번 안해도 됨
            - Sequence, Table에서 이용. 동시성 문제 X
    기본 키 제약 조건 : null 아님, 유일, 변하면 안됨.
        만족하는 자연키 찾기 어려움 -> 대체키 사용
    권장 : Long형 + 대체키 + 키 생성전략 사용

<요구사항 분석과 기본 매핑>
    회원 - 주문 : 일대다
    주문 - 상품 : 다대다
    -> 주문 상품 만들어 일대다 다대일로 만듦
    데이터 중심 설계의 문제점
        - 테이블의 외래키를 객체에 그대로 가져옴
        - 객체 그래프 탐색이 불가능
        - 참조가 없으므로 UML도 잘못됨

<단방향 연관관계>
    select * from member m join team t on m.team_id = t.team_id;
    객체를 테이블에 맞추어 데이터 중심으로 모델링하면 협력 관계를 만들 수 없음.
    단방향 연관관계
    member 입장에서 Many라서 @ManyToOne, @JoinColumn 이용하면 매핑 가능